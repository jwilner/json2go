// Code generated by jsonschema2go. DO NOT EDIT.
package foo

import (
	"encoding/json"
	"fmt"
	"github.com/jwilner/jsonschema2go/pkg/boxed"
	"math"
	"regexp"
)

// Bar gives you some dumb info
// generated from https://example.com/testdata/generate/field_validators/foo/bar.json
type Bar struct {
	Array       BarArray      `json:"array,omitempty"`
	ExclInteger boxed.Int64   `json:"exclInteger"`
	ExclNumber  boxed.Float64 `json:"exclNumber"`
	Integer     boxed.Int64   `json:"integer"`
	Number      boxed.Float64 `json:"number"`
	String      boxed.String  `json:"string"`
}

var (
	barStringPattern = regexp.MustCompile(`^(123|456)$`)
)

func (m *Bar) Validate() error {
	if !m.String.Set {
		return &validationError{
			errType:  "required",
			message:  "field required",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
		}
	}
	if err := m.Array.Validate(); err != nil {
		if err, ok := err.(valErr); ok {
			return &validationError{
				errType:  err.ErrType(),
				message:  err.Message(),
				path:     append([]interface{}{"Array"}, err.Path()...),
				jsonPath: append([]interface{}{"array"}, err.JSONPath()...),
			}
		}
		return err
	}
	if m.ExclInteger.Set && m.ExclInteger.Int64 >= 1 {
		return &validationError{
			errType:  "maximumExclusive",
			path:     []interface{}{"ExclInteger"},
			jsonPath: []interface{}{"exclInteger"},
			message:  fmt.Sprintf("must be less than 1 but was %v", m.ExclInteger.Int64),
		}
	}
	if m.ExclInteger.Set && m.ExclInteger.Int64 <= 1 {
		return &validationError{
			errType:  "minimumExclusive",
			path:     []interface{}{"ExclInteger"},
			jsonPath: []interface{}{"exclInteger"},
			message:  fmt.Sprintf("must be greater than 1 but was %v", m.ExclInteger.Int64),
		}
	}
	if m.ExclNumber.Set && m.ExclNumber.Float64 >= 1 {
		return &validationError{
			errType:  "maximumExclusive",
			path:     []interface{}{"ExclNumber"},
			jsonPath: []interface{}{"exclNumber"},
			message:  fmt.Sprintf("must be less than 1 but was %v", m.ExclNumber.Float64),
		}
	}
	if m.ExclNumber.Set && m.ExclNumber.Float64 <= 1 {
		return &validationError{
			errType:  "minimumExclusive",
			path:     []interface{}{"ExclNumber"},
			jsonPath: []interface{}{"exclNumber"},
			message:  fmt.Sprintf("must be greater than 1 but was %v", m.ExclNumber.Float64),
		}
	}
	if m.Integer.Set && m.Integer.Int64 > 1 {
		return &validationError{
			errType:  "maximum",
			path:     []interface{}{"Integer"},
			jsonPath: []interface{}{"integer"},
			message:  fmt.Sprintf("must be less than or equal to 1 but was %v", m.Integer.Int64),
		}
	}
	if m.Integer.Set && m.Integer.Int64 < 1 {
		return &validationError{
			errType:  "minimum",
			path:     []interface{}{"Integer"},
			jsonPath: []interface{}{"integer"},
			message:  fmt.Sprintf("must be greater than or equal to 1 but was %v", m.Integer.Int64),
		}
	}
	if m.Integer.Set && m.Integer.Int64%3 != 0 {
		return &validationError{
			errType:  "multipleOf",
			path:     []interface{}{"Integer"},
			jsonPath: []interface{}{"integer"},
			message:  fmt.Sprintf("must be a multiple of 3 but was %v", m.Integer.Int64),
		}
	}
	if m.Number.Set && m.Number.Float64 > 1 {
		return &validationError{
			errType:  "maximum",
			path:     []interface{}{"Number"},
			jsonPath: []interface{}{"number"},
			message:  fmt.Sprintf("must be less than or equal to 1 but was %v", m.Number.Float64),
		}
	}
	if m.Number.Set && m.Number.Float64 < 1 {
		return &validationError{
			errType:  "minimum",
			path:     []interface{}{"Number"},
			jsonPath: []interface{}{"number"},
			message:  fmt.Sprintf("must be greater than or equal to 1 but was %v", m.Number.Float64),
		}
	}
	if m.Number.Set && math.Mod(m.Number.Float64, 3.2) != 0 {
		return &validationError{
			errType:  "multipleOf",
			path:     []interface{}{"Number"},
			jsonPath: []interface{}{"number"},
			message:  fmt.Sprintf("must be a multiple of 3.2 but was %v", m.Number.Float64),
		}
	}
	if len(m.String.String) > 10 {
		return &validationError{
			errType:  "maxLength",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
			message:  fmt.Sprintf("must have length less than 10 but was %d", len(m.String.String)),
		}
	}
	if len(m.String.String) < 3 {
		return &validationError{
			errType:  "minLength",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
			message:  fmt.Sprintf("must have length greater than 3 but was %d", len(m.String.String)),
		}
	}
	if !barStringPattern.MatchString(m.String.String) {
		return &validationError{
			errType:  "pattern",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
			message:  fmt.Sprintf("must match '^(123|456)$' but got %q", m.String.String),
		}
	}
	return nil
}

func (m *Bar) MarshalJSON() ([]byte, error) {
	inner := struct {
		Array       BarArray `json:"array,omitempty"`
		ExclInteger *int64   `json:"exclInteger,omitempty"`
		ExclNumber  *float64 `json:"exclNumber,omitempty"`
		Integer     *int64   `json:"integer,omitempty"`
		Number      *float64 `json:"number,omitempty"`
		String      *string  `json:"string,omitempty"`
	}{
		Array: m.Array,
	}
	if m.ExclInteger.Set {
		inner.ExclInteger = &m.ExclInteger.Int64
	}
	if m.ExclNumber.Set {
		inner.ExclNumber = &m.ExclNumber.Float64
	}
	if m.Integer.Set {
		inner.Integer = &m.Integer.Int64
	}
	if m.Number.Set {
		inner.Number = &m.Number.Float64
	}
	if m.String.Set {
		inner.String = &m.String.String
	}
	return json.Marshal(inner)
}

// generated from https://example.com/testdata/generate/field_validators/foo/bar.json#/properties/array
type BarArray []string

func (m BarArray) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte(`[]`), nil
	}
	return json.Marshal([]string(m))
}

func (m BarArray) Validate() error {
	if len(m) > 10 {
		return &validationError{
			errType: "maxItems",
			message: fmt.Sprintf("must have length greater than 10 but was %d", len(m)),
		}
	}
	if len(m) < 1 {
		return &validationError{
			errType: "minItems",
			message: fmt.Sprintf("must have length greater than 1 but was %d", len(m)),
		}
	}
	seen := make(map[string]bool)
	for i, v := range m {
		if seen[v] {
			return &validationError{
				errType:  "uniqueItems",
				message:  fmt.Sprintf("items must be unique but %v occurs more than once", v),
				path:     []interface{}{i},
				jsonPath: []interface{}{i},
			}
		}
		seen[v] = true
	}
	return nil
}

type valErr interface {
	ErrType() string
	JSONPath() []interface{}
	Path() []interface{}
	Message() string
}

type validationError struct {
	errType, message string
	jsonPath, path   []interface{}
}

func (e *validationError) ErrType() string {
	return e.errType
}

func (e *validationError) JSONPath() []interface{} {
	return e.jsonPath
}

func (e *validationError) Path() []interface{} {
	return e.path
}

func (e *validationError) Message() string {
	return e.message
}

func (e *validationError) Error() string {
	return fmt.Sprintf("%v: %v", e.path, e.message)
}

var _ valErr = new(validationError)
