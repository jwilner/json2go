// Code generated by jsonschema2go. DO NOT EDIT.
package foo

import (
	"encoding/json"
	"fmt"
	"math"
	"regexp"
)

// Bar gives you some dumb info
// generated from https://example.com/testdata/generate/field_validators/foo/bar.json
type Bar struct {
	Array       BarArray `json:"array"`
	ExclInteger *int64   `json:"exclInteger,omitempty"`
	ExclNumber  *float64 `json:"exclNumber,omitempty"`
	Integer     *int64   `json:"integer,omitempty"`
	Number      *float64 `json:"number,omitempty"`
	String      *string  `json:"string,omitempty"`
}

var (
	barStringPattern = regexp.MustCompile(`^(123|456)$`)
)

func (m *Bar) Validate() error {
	if m.String == nil {
		return &validationError{
			errType:  "required",
			message:  "field required",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
		}
	}
	if err := m.Array.Validate(); err != nil {
		if err, ok := err.(valErr); ok {
			return &validationError{
				errType:  err.ErrType(),
				message:  err.Message(),
				path:     append([]interface{}{"Array"}, err.Path()...),
				jsonPath: append([]interface{}{"array"}, err.JSONPath()...),
			}
		}
		return err
	}
	if m.ExclInteger != nil && *m.ExclInteger >= 1 {
		return &validationError{
			errType:  "maximumExclusive",
			path:     []interface{}{"ExclInteger"},
			jsonPath: []interface{}{"exclInteger"},
			message:  fmt.Sprintf("must be less than 1 but was %v", *m.ExclInteger),
		}
	}
	if m.ExclInteger != nil && *m.ExclInteger <= 1 {
		return &validationError{
			errType:  "minimumExclusive",
			path:     []interface{}{"ExclInteger"},
			jsonPath: []interface{}{"exclInteger"},
			message:  fmt.Sprintf("must be greater than 1 but was %v", *m.ExclInteger),
		}
	}
	if m.ExclNumber != nil && *m.ExclNumber >= 1 {
		return &validationError{
			errType:  "maximumExclusive",
			path:     []interface{}{"ExclNumber"},
			jsonPath: []interface{}{"exclNumber"},
			message:  fmt.Sprintf("must be less than 1 but was %v", *m.ExclNumber),
		}
	}
	if m.ExclNumber != nil && *m.ExclNumber <= 1 {
		return &validationError{
			errType:  "minimumExclusive",
			path:     []interface{}{"ExclNumber"},
			jsonPath: []interface{}{"exclNumber"},
			message:  fmt.Sprintf("must be greater than 1 but was %v", *m.ExclNumber),
		}
	}
	if m.Integer != nil && *m.Integer > 1 {
		return &validationError{
			errType:  "maximum",
			path:     []interface{}{"Integer"},
			jsonPath: []interface{}{"integer"},
			message:  fmt.Sprintf("must be less than or equal to 1 but was %v", *m.Integer),
		}
	}
	if m.Integer != nil && *m.Integer < 1 {
		return &validationError{
			errType:  "minimum",
			path:     []interface{}{"Integer"},
			jsonPath: []interface{}{"integer"},
			message:  fmt.Sprintf("must be greater than or equal to 1 but was %v", *m.Integer),
		}
	}
	if m.Integer != nil && *m.Integer%3 != 0 {
		return &validationError{
			errType:  "multipleOf",
			path:     []interface{}{"Integer"},
			jsonPath: []interface{}{"integer"},
			message:  fmt.Sprintf("must be a multiple of 3 but was %v", *m.Integer),
		}
	}
	if m.Number != nil && *m.Number > 1 {
		return &validationError{
			errType:  "maximum",
			path:     []interface{}{"Number"},
			jsonPath: []interface{}{"number"},
			message:  fmt.Sprintf("must be less than or equal to 1 but was %v", *m.Number),
		}
	}
	if m.Number != nil && *m.Number < 1 {
		return &validationError{
			errType:  "minimum",
			path:     []interface{}{"Number"},
			jsonPath: []interface{}{"number"},
			message:  fmt.Sprintf("must be greater than or equal to 1 but was %v", *m.Number),
		}
	}
	if m.Number != nil && math.Mod(*m.Number, 3.2) != 0 {
		return &validationError{
			errType:  "multipleOf",
			path:     []interface{}{"Number"},
			jsonPath: []interface{}{"number"},
			message:  fmt.Sprintf("must be a multiple of 3.2 but was %v", *m.Number),
		}
	}
	if len(*m.String) > 10 {
		return &validationError{
			errType:  "maxLength",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
			message:  fmt.Sprintf("must have length less than 10 but was %d", len(*m.String)),
		}
	}
	if len(*m.String) < 3 {
		return &validationError{
			errType:  "minLength",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
			message:  fmt.Sprintf("must have length greater than 3 but was %d", len(*m.String)),
		}
	}
	if !barStringPattern.MatchString(*m.String) {
		return &validationError{
			errType:  "pattern",
			path:     []interface{}{"String"},
			jsonPath: []interface{}{"string"},
			message:  fmt.Sprintf(`must match '^(123|456)$' but got %q`, *m.String),
		}
	}
	return nil
}

// generated from https://example.com/testdata/generate/field_validators/foo/bar.json#/properties/array
type BarArray []string

func (m BarArray) MarshalJSON() ([]byte, error) {
	if m == nil {
		return []byte(`[]`), nil
	}
	return json.Marshal([]string(m))
}

func (m BarArray) Validate() error {
	if len(m) > 10 {
		return &validationError{
			errType: "maxItems",
			message: fmt.Sprintf("must have length greater than 10 but was %d", len(m)),
		}
	}
	if len(m) < 1 {
		return &validationError{
			errType: "minItems",
			message: fmt.Sprintf("must have length greater than 1 but was %d", len(m)),
		}
	}
	seen := make(map[string]bool)
	for i, v := range m {
		if seen[v] {
			return &validationError{
				errType:  "uniqueItems",
				message:  fmt.Sprintf("items must be unique but %v occurs more than once", v),
				path:     []interface{}{i},
				jsonPath: []interface{}{i},
			}
		}
		seen[v] = true
	}
	return nil
}

type valErr interface {
	ErrType() string
	JSONPath() []interface{}
	Path() []interface{}
	Message() string
}

type validationError struct {
	errType, message string
	jsonPath, path   []interface{}
}

func (e *validationError) ErrType() string {
	return e.errType
}

func (e *validationError) JSONPath() []interface{} {
	return e.jsonPath
}

func (e *validationError) Path() []interface{} {
	return e.path
}

func (e *validationError) Message() string {
	return e.message
}

func (e *validationError) Error() string {
	return fmt.Sprintf("%v: %v", e.path, e.message)
}

var _ valErr = new(validationError)
