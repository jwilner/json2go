package print

import (
	"bytes"
	"context"
	"github.com/ns1/jsonschema2go/internal/composite"
	"github.com/ns1/jsonschema2go/internal/slice"
	"github.com/ns1/jsonschema2go/pkg/gen"
	"github.com/stretchr/testify/require"
	"go/format"
	"testing"
)

func TestImports_List(t *testing.T) {
	tests := []struct {
		name          string
		currentGoPath string
		importGoPaths []string
		wantImports   []gen.Import
	}{
		{
			"empty",
			"github.com/ns1/jsonschema2go",
			[]string{},
			nil,
		},
		{
			"alias",
			"github.com/ns1/jsonschema2go",
			[]string{
				"github.com/ns1/jsonschema2go/example",
				"github.com/ns1/jsonschema2go/foo/example",
			},
			[]gen.Import{
				{"github.com/ns1/jsonschema2go/example", ""},
				{"github.com/ns1/jsonschema2go/foo/example", "example2"},
			},
		},
		{
			"multiple",
			"github.com/ns1/jsonschema2go",
			[]string{"encoding/json", "encoding/json"},
			[]gen.Import{
				{"encoding/json", ""},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.wantImports, gen.NewImports(tt.currentGoPath, tt.importGoPaths).List())
		})
	}
}

func TestImports_QualName(t *testing.T) {
	tests := []struct {
		name          string
		currentGoPath string
		importGoPaths []string
		typeInfo      gen.TypeInfo
		want          string
	}{
		{
			"builtin",
			"github.com/ns1/jsonschema2go",
			[]string{"github.com/ns1/jsonschema2go/example", "github.com/ns1/jsonschema2go/foo/example"},
			gen.TypeInfo{Name: "int"},
			"int",
		},
		{
			"external",
			"github.com/ns1/jsonschema2go",
			[]string{"github.com/ns1/jsonschema2go/example", "github.com/ns1/jsonschema2go/foo/example"},
			gen.TypeInfo{GoPath: "github.com/ns1/jsonschema2go", Name: "Bob"},
			"Bob",
		},
		{
			"external",
			"github.com/ns1/jsonschema2go",
			[]string{"github.com/ns1/jsonschema2go/example", "github.com/ns1/jsonschema2go/foo/example"},
			gen.TypeInfo{GoPath: "github.com/ns1/jsonschema2go/example", Name: "Bob"},
			"example.Bob",
		},
		{
			"external with alias",
			"github.com/ns1/jsonschema2go",
			[]string{"github.com/ns1/jsonschema2go/example", "github.com/ns1/jsonschema2go/foo/example"},
			gen.TypeInfo{GoPath: "github.com/ns1/jsonschema2go/foo/example", Name: "Bob"},
			"example2.Bob",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			require.Equal(t, tt.want, gen.NewImports(tt.currentGoPath, tt.importGoPaths).QualName(tt.typeInfo))
		})
	}
}

func TestPrintFile(t *testing.T) {
	errBit := `
type valErr interface {
	ErrType() string
	JSONPath() []interface{}
	Path() []interface{}
	Message() string
}

type validationError struct {
	errType, message string
	jsonPath, path   []interface{}
}

func (e *validationError) ErrType() string {
	return e.errType
}

func (e *validationError) JSONPath() []interface{} {
	return e.jsonPath
}

func (e *validationError) Path() []interface{} {
	return e.path
}

func (e *validationError) Message() string {
	return e.message
}

func (e *validationError) Error() string {
	return fmt.Sprintf("%v: %v", e.path, e.message)
}

var _ valErr = new(validationError)
`

	tests := []struct {
		name    string
		goPath  string
		plans   []gen.Plan
		wantW   string
		wantErr bool
	}{
		{
			name:   "simple struct",
			goPath: "github.com/ns1/jsonschema2go",
			plans: []gen.Plan{
				&composite.StructPlan{
					Comment: "Bob does lots of cool things",
					Fields: []composite.StructField{
						{Name: "Count", Type: gen.TypeInfo{Name: "int"}, Tag: tag(`json:"count,omitempty"`)},
					},
					TypeInfo: gen.TypeInfo{
						Name: "Bob",
					},
				},
			},
			wantW: `
// Code generated by jsonschema2go. DO NOT EDIT.
package jsonschema2go

import (
	"fmt"
)

// Bob is generated from <nil>
// Bob does lots of cool things
type Bob struct {
	Count int ` + "`" + `json:"count,omitempty"` + "`" + `
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *Bob) Validate() error {
	return nil
}
` + errBit,
		},
		{
			name:   "struct with qualified field",
			goPath: "github.com/ns1/jsonschema2go",
			plans: []gen.Plan{
				&composite.StructPlan{
					Comment: "Bob does lots of cool things",
					Fields: []composite.StructField{
						{Name: "Count", Type: gen.TypeInfo{Name: "int"}, Tag: tag(`json:"count,omitempty"`)},
						{
							Name: "Other",
							Type: gen.TypeInfo{
								GoPath: "github.com/ns1/jsonschema2go/blah",
								Name:   "OtherType",
							},
							Tag: tag(`json:"other,omitempty"`),
						},
					},
					TypeInfo: gen.TypeInfo{
						Name: "Bob",
					},
				},
			},
			wantW: `
// Code generated by jsonschema2go. DO NOT EDIT.
package jsonschema2go

import (
	"fmt"
	"github.com/ns1/jsonschema2go/blah"
)

// Bob is generated from <nil>
// Bob does lots of cool things
type Bob struct {
	Count int 				` + "`" + `json:"count,omitempty"` + "`" + `
	Other blah.OtherType 	` + "`" + `json:"other,omitempty"` + "`" + `
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *Bob) Validate() error {
	return nil
}

` + errBit,
		},
		{
			name:   "struct with aliased import",
			goPath: "github.com/ns1/jsonschema2go",
			plans: []gen.Plan{
				&composite.StructPlan{
					Comment: "Bob does lots of cool things",
					Fields: []composite.StructField{
						{Name: "Count", Type: gen.TypeInfo{Name: "int"}, Tag: tag(`json:"count,omitempty"`)},
						{
							Name: "Other",
							Type: gen.TypeInfo{
								GoPath:  "github.com/ns1/jsonschema2go/blah",
								Name:    "OtherType",
								Pointer: true,
							},
							Tag: tag(`json:"other,omitempty"`),
						},
						{
							Name: "OtherOther",
							Type: gen.TypeInfo{
								GoPath: "github.com/ns1/jsonschema2go/bob/blah",
								Name:   "AnotherType",
							},
							Tag: tag(`json:"another,omitempty"`),
						},
					},
					TypeInfo: gen.TypeInfo{
						Name: "Bob",
					},
				},
			},
			wantW: `
// Code generated by jsonschema2go. DO NOT EDIT.
package jsonschema2go

import (
	"fmt"
	"github.com/ns1/jsonschema2go/blah"
	blah2 "github.com/ns1/jsonschema2go/bob/blah"
)

// Bob is generated from <nil>
// Bob does lots of cool things
type Bob struct {
	Count 		int 				` + "`" + `json:"count,omitempty"` + "`" + `
	Other 		*blah.OtherType 	` + "`" + `json:"other,omitempty"` + "`" + `
	OtherOther 	blah2.AnotherType 	` + "`" + `json:"another,omitempty"` + "`" + `
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *Bob) Validate() error {
	return nil
}

` + errBit,
		},
		{
			name:   "struct with embedded",
			goPath: "github.com/ns1/jsonschema2go",
			plans: []gen.Plan{
				&composite.StructPlan{
					Comment: "Bob does lots of cool things",
					Fields: []composite.StructField{
						{
							Type: gen.TypeInfo{
								GoPath: "github.com/ns1/jsonschema2go/blah",
								Name:   "OtherType",
							},
						},
					},
					TypeInfo: gen.TypeInfo{
						Name: "Bob",
					},
				},
			},
			wantW: `
// Code generated by jsonschema2go. DO NOT EDIT.
package jsonschema2go

import (
	"fmt"
	"github.com/ns1/jsonschema2go/blah"
)

// Bob is generated from <nil>
// Bob does lots of cool things
type Bob struct {
	blah.OtherType
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *Bob) Validate() error {
	return nil
}

` + errBit,
		},
		{
			name:   "struct with embedded",
			goPath: "github.com/ns1/jsonschema2go",
			plans: []gen.Plan{
				&composite.StructPlan{
					Comment: "Bob does lots of cool things",
					Fields: []composite.StructField{
						{
							Type: gen.TypeInfo{
								GoPath: "github.com/ns1/jsonschema2go",
								Name:   "OtherType",
							},
						},
					},
					TypeInfo: gen.TypeInfo{
						Name: "Bob",
					},
				},
				&composite.StructPlan{
					Comment: "OtherType does lots of cool things",
					Fields: []composite.StructField{
						{Type: gen.TypeInfo{Name: "int"}, Name: "Count", Tag: tag(`json:"count,omitempty"`)},
					},
					TypeInfo: gen.TypeInfo{
						Name: "OtherType",
					},
				},
			},
			wantW: `
// Code generated by jsonschema2go. DO NOT EDIT.
package jsonschema2go

import (
	"fmt"
)

// Bob is generated from <nil>
// Bob does lots of cool things
type Bob struct {
	OtherType
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *Bob) Validate() error {
	return nil
}

// OtherType is generated from <nil>
// OtherType does lots of cool things
type OtherType struct {
	Count int ` + "`" + `json:"count,omitempty"` + "`" + `
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *OtherType) Validate() error {
	return nil
}

` + errBit,
		},
		{
			name:   "array with struct",
			goPath: "github.com/ns1/jsonschema2go",
			plans: []gen.Plan{
				&slice.Plan{
					TypeInfo: gen.TypeInfo{
						Name: "Bob",
					},
					Comment: "Bob does lots of cool things",
					ItemType: gen.TypeInfo{
						GoPath:  "github.com/ns1/jsonschema2go",
						Name:    "OtherType",
						Pointer: true,
					},
				},
				&composite.StructPlan{
					Comment: "OtherType does lots of cool things",
					Fields: []composite.StructField{
						{Type: gen.TypeInfo{Name: "int"}, Name: "Count", Tag: tag(`json:"count,omitempty"`)},
					},
					TypeInfo: gen.TypeInfo{
						Name: "OtherType",
					},
				},
			},
			wantW: `
// Code generated by jsonschema2go. DO NOT EDIT.
package jsonschema2go

import (
	"fmt"
)

// OtherType is generated from <nil>
// OtherType does lots of cool things
type OtherType struct {
	Count int ` + "`" + `json:"count,omitempty"` + "`" + `
}

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m *OtherType) Validate() error {
	return nil
}

// Bob is generated from <nil>
// Bob does lots of cool things
type Bob []*OtherType

// Validate returns an error if this value is invalid according to rules defined in <nil>
func (m Bob) Validate() error {
	return nil
}

` + errBit,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var w bytes.Buffer
			err := New(nil).Print(gen.SetDebug(context.Background()), &w, tt.goPath, tt.plans)
			if (err != nil) != tt.wantErr {
				t.Fatalf("printStruct() error = %v, wantErr %v, output: %s", err, tt.wantErr, w.String())
			}
			formatted, err := format.Source(w.Bytes())
			if err != nil {
				t.Fatalf("unable to format: %v", err)
			}
			formattedWant, err := format.Source([]byte(tt.wantW))
			if err != nil {
				t.Fatalf("unable to format wanted: %v", err)
			}
			require.Equal(t, string(formattedWant), string(formatted))
		})
	}
}

func tag(s string) string {
	return "`" + s + "`"
}
